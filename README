Note: For CERN testing...
Actual README for CERN is in CERNtestscripts directory





Overview of BSD CDAQ development software and hardware.
First Version Generated By: Tyler Anderson, Penn State University 
Date: Wed Mar 20 16:25:21 EDT 2013

For Questions and comments contact: 
Tyler Anderson (tba109@psu.edu) 
Sai Im (imsain@gmail.com)

-----------------------------------------------------------------------------------------
1.) BSD CDAQ development package overview

Parts in the hardware package:
a.) A simple USB board based around the FX2LP USB-2.0 microcontroller has been provided
b.) A power cable with flying leads for providing power to the USB board
c.) A simple jumper cable.

Instructions for powering on the board:
a.) Start with the USB board powered off, and it's power cable disconnected from the
    USB board
b.) Attach the free end of the red wire to a +3.3V power supply. Attach the free end 
    of the black wire to the power supplies return (i.e. signal ground).
c.) Power on the supply.
d.) Plug the power cable in to the USB board.
e.) from a linux bash shell, type: "lsusb". The device "Cypress Semiconductor Corp." 
    with vendor ID number 0x04b4 and product ID number 0x1801 should appear. This is
    the vendor and product ID for the BSD USB interface. After firmware download, the
    product ID changes to 0x1801.

The BSD software package provided by PSU is located in the directory 
BSD_software_Mar20_2013_v1_0.tgz. the Linux "libusb" library is used as the USB API.

To compile the BSD readout software, untar, cd into the directory, and type "make".
This will compile both the SFC software rountines (section 2) and various GSE standalone
programs which demonstrate the operation of the BSD software (section 3).

The USB board uses EP2IN for incoming commands from the SFC, EP4IN as a general 
"USB FIFO reset" command endpoint, EP6OUT for sending responses to these commands, and
EP8OUT for reading out event data. 

Note that in order to trigger the USB board to readout out events, JX1-13 on the 
USB board must be driven high by a +3.3V voltage, and driven low to inhibit triggering.
JX1-13 should ALWAYS be tied to either +3.3V (JX1-49) to generate USB Board event readout
triggers or to 0V (JX1-50) to inhibit these triggers. It can also be driven by a square pulse
with +3.3V to 0V levels. JX1-13 is recommended NOT to be left floating.

A list of commands is available from the document docs/BSD_command_list_Mar20_2013.pdf.

A break down of the event, command, and housekeeping packet format is available from the
document docs/BSD_event_hk_command_packet_Mar20_2013.pdf.

-----------------------------------------------------------------------------------------
2.) SFC software

Overview of the base classes:
BSDUsb: Basic USB endpoint setup and data transfer.
BSDCmd: Class to parse BSD commands and responses from the BSD system.
BSDEvt: Class to parse BSD events. 
HBSD: Encapsulating class for the BSDUsb, BSDCmd, and BSDEvt classes. This is the only
      class the CDAQ should have to interface to directly.

-----------------------------------------------------------------------------------------
3.) GSE standalone programs

The GSE standalone programs show how the HBSD class is used, and will be used for
diagnosising and troubleshooting the BSD on the ground. A description of each program,
along with an example of its usage, will be given below. The source code for these programs 
is located in gse/utils

=================
a.) reset.exe: Load the firware onto the USB board. Note that this command needs to
    be run after each power on of the USB board. 

example: Run the reset program. A message showing the response bytes from EP6 will
	 appear.

=================
b.) EP2OUT.exe: Write N bytes (as hex) to EP2. This is for hardware level testing and
    debugging only

example: Writing the NOP command
$: ./EP2OUT.exe 8f c7 ab ba 00 00 00 00
EP2OUT Write: 0x8F 0xC7 0xAB 0xBA 0x00 0x00 0x00 0x00 

Note: When writing to the USB interface with EP2OUT.exe, one should always follow
up with an EP6IN.exe in order to read the response. Otherwise, commands and responses may
become unsynchronized. The one exception is if the "software generated event"
command is written, in which case the response will be an event data packet on
EP8. In that case, the EP2OUT.exe write should be followed up by a EP8IN.exe read.

=================
c.) EP6IN.exe: Read N bytes (as hex) from EP6. This is for hardware level testing and 
    debugging only.

example: Write the NOP command to EP2 and read out the response from EP6
$: ./EP2OUT.exe 8f c7 ab ba 00 00 00 00
EP2OUT Write: 0x8F 0xC7 0xAB 0xBA 0x00 0x00 0x00 0x00 
$: ./EP6IN.exe 
EP6IN Read:   0x8F 0xC7 0xBC 0xCB 0x00 0x00 0x00 0x01 

=================
d.) EP4OUT.exe: Write N bytes (as hex) to EP4. This is for hardware level testing and
    debugging only. Note that writing ANY packet, no matter the contents, to EP4
    resets the USB FIFOs. This is used to correct sync slips.
$: ./EP4OUT
EP4OUT Write: 0x8F 0xC7 0xAB 0xBA 0x06 0x00 0x00 0x00 

Note: When writing to the USB interface with EP4OUT.exe, one should always follow
up with an EP6IN.exe, to read the response. Otherwise, commands and responses may
become unsynchronized.

=================
e.) EP8IN.exe: Read N bytes (as hex) from EP8. This is for hardware level testing and
    debugging only.

example: First send the command for a software generated event. Then readout EP8.
$: ./EP2OUT.exe 8f c7 ab ba 04 00 00 00
EP2OUT Write: 0x8F 0xC7 0xAB 0xBA 0x04 0x00 0x00 0x00 
$: ./EP8IN.exe 
EP8IN Read:   0x8F 0xC7 0xCD 0xDC 0x04 0x05 0x06 0x07 0x22 0x09 0x0A 0x0B 0x0C 0x0D 0x0E 0x0F 0x10 0x11 0x12 0x13 0x14 0x15 0x16 0x17 0x18 0x19 0x1A 0x1B 0x1C 0x1D 0x1E 0x1F 0x20 0x21 0x22 0x23 0x24 0x25 0x26 0x27 0x28 0x29 0x2A 0x2B 0x2C 0x2D 0x2E 0x2F 0x30 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39 0x3A 0x3B 0x3C 0x3D 0x3E 0x3F 0x40 0x41 0x42 0x43 0x44 0x45 0x46 0x47 0x48 0x49 0x4A 0x4B 0x4C 0x4D 0x4E 0x4F 0x50 0x51

=================
f.) getconf.exe: Get the protoBSD's current configuration (i.e. the value of all BSD parameters and status)

example: Run the command and see the results
$: ./getconf.exe 
main: Opening BSD USB device
tcf_for_bsd.h = 0

               PEDX    D1X_DL    D1X_WD    D2X_DL    D2X_WD    D3X_DL    D3X_WD   DONX_DL   DONX_WD      HV1X      HV2X      HV3X
Quartet1:      2049        19      4999        24      4999       249      4999         4      4999         0         0         0
Quartet2:      2049        19      4999        24      4999       249      4999         4      4999         0         0         0
Quartet3:      2049        19      4999        24      4999       249      4999         4      4999         0         0         0
Quartet4:      2049        19      4999        24      4999       249      4999         4      4999         0         0         0


              PEDTX   D1TX_DL   D2TX_DL   D3TX_DL   D1TX_WD   D2TX_WD   D3TX_WD      THRX      HVTX
Trigger1:      2049         0      4999         4      4999        49      4999      4095         0
Trigger2:      2049         0      4999         4      4999        49      4999      4095         0


            TRIG_MODE      CONF_MODE       COINC_WD       RECOV_WD         DIG_DL     TRIG1_RATE     TRIG2_RATE      SELF_RATE        MT_RATE        T0_RATE
FPGA:               0              0              4            195              8              0              0              0              0              0

            PULSEX_DL    PULSEX_WD   PULSEX_AMP    PULSEX_ON
PULSE1:             0            1         4095            0
PULSE2:            29            1         2867            0

=================
g.) command.exe: Send a pneumonic command to the protoBSD. Pneumonic commands can 
    be "NOP" "GET" "SET" "INIT" and "RESET". See the document
    "BSD_command_list_Mar20_2013.pdf" for a complete list of all possible commands

example: Set a parameter with the SET command. Then readback its value with the GET command. 
$: ./command.exe

Enter commands in mnemonic form, and the 
response will be shown, along with any 
error messages
------------------------------------------------
Send command: 
SET HV22 1000 

Response value: 1000
------------------------------------------------
Send command: 
GET HV22

Response value: 1000
------------------------------------------------
^C

=================
h.) event.exe: Poll for and readout events from the BSD. These are generated by
    +3.3V on JX1-13. Note that this program also creates a timestamped, raw text
    file with the collected BSD data in it.

example: Connect JX1-13 to JX1-49 via the yellow jumper wire. (Note: this provides
+3.3V to JX1-13, hence enabling triggering.) Then run the command:
$: ./event.exe
----------------------------------------------------------------------------------------
Loop 3812
curevt.event_number = 67438087
     EVTNO    EVTCNT     TRIG_MODE     CONF_MODE     TRIG2     TRIG1     EXTIN
  67438087       225             0             1         0         0         1

          PMT1   PMT2   PMT3   PMT4   PMT5   PMT6   PMT7   PMT8   PMT9   PMT10   PMT11   PMT12   PMT13   PMT14   PMT15   PMT16  PMTT1  PMTT2
LG:       2571   3599   4627   5655   6683   7711   8739   9767  10795   11823   12851   13879   14907   15935   16963   17991  19019  20047
HG:       2571   3599   4627   5655   6683   7711   8739   9767  10795   11823   12851   13879   14907   15935   16963   17991  19533  20561
----------------------------------------------------------------------------------------

Many lines similar to the above appear, displaying the contents of the 
BSD event data packet. The EVTCNT parameter gets incremented by the USB board's
firmware. The loop number is simply a firmware counter for the event. All other
data values remain constant.

=================
i.) event_software_generated.exe: Generate a software command and read it out.
    "software generated" means that the event readout is initiated on command,
    not from a hardware trigger. 

example: Connect JX1-13 to JX1-50 via the yellow jumper wire. Note that this means no
hardware trigger is provided to the USB Board. Then run the command:
$: ./event_software_generated.exe
----------------------------------------------------------------------------------------
Loop 3812
curevt.event_number = 67438087
     EVTNO    EVTCNT     TRIG_MODE     CONF_MODE     TRIG2     TRIG1     EXTIN
  67438087       225             0             1         0         0         1

          PMT1   PMT2   PMT3   PMT4   PMT5   PMT6   PMT7   PMT8   PMT9   PMT10   PMT11   PMT12   PMT13   PMT14   PMT15   PMT16  PMTT1  PMTT2
LG:       2571   3599   4627   5655   6683   7711   8739   9767  10795   11823   12851   13879   14907   15935   16963   17991  19019  20047
HG:       2571   3599   4627   5655   6683   7711   8739   9767  10795   11823   12851   13879   14907   15935   16963   17991  19533  20561
----------------------------------------------------------------------------------------


